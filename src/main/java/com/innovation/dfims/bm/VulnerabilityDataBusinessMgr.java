package com.innovation.dfims.bm;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.dao.DataAccessException;
import org.springframework.stereotype.Service;

import com.innovation.dfims.ai.utils.CommonUtils;
import com.innovation.dfims.ai.utils.HistoricalDataUtils;
import com.innovation.dfims.config.AppConstant;
import com.innovation.dfims.dao.IVulnerabilityDataDao;
import com.innovation.dfims.dto.AuditRecord;
import com.innovation.dfims.dto.UserContactRecords;
import com.innovation.dfims.exptn.AppException;

@Service("vulnerabilityDataBusinessMgr")
public class VulnerabilityDataBusinessMgr implements IVulnerabilityDataBusinessMgr {
	
	private int alarm = 0;
	private static Map<Integer, String> disasterTypeMap = CommonUtils.populateDisasterIdMap();
	private static String areaZipCode = "700091";
	private List<String> infoList = null;
	
	private int thresholdVulneabiltyVal = HistoricalDataUtils.populateThresholdVulnerabilityVal();
	
	private IVulnerabilityDataDao vulnerabilityDataDao = null;

	public IVulnerabilityDataDao getVulnerabilityDataDao() {
		return vulnerabilityDataDao;
	}

	@Autowired
	@Qualifier("vulnerabilityDataDao")
	public void setVulnerabilityDataDao(IVulnerabilityDataDao vulnerabilityDataDao) {
		this.vulnerabilityDataDao = vulnerabilityDataDao;
	}

	private List<AuditRecord> fetchAuditRecords() throws AppException {
		List<AuditRecord> auditRecords = null;
		try {
			auditRecords = getVulnerabilityDataDao().fetchAuditRecords();
		} catch (DataAccessException ex) {
			throw new AppException(ex, ex.getMessage());
		}
		return auditRecords;
	}

	@Override
	public boolean insertVulnerabilityRecords() throws AppException {
		boolean recordsInserted = false;
		List<AuditRecord> rawAuditRecords = fetchAuditRecords();
		List<AuditRecord> vulnerableRecords = fetchVulnerableRecords(rawAuditRecords);
		if(!vulnerableRecords.isEmpty()){
			try {
				String queryStatus = getVulnerabilityDataDao()
						.insertVulnerabiltyRecords(vulnerableRecords);
				if (AppConstant.STATUS_SUCCESS.equalsIgnoreCase(queryStatus)) {
					recordsInserted = true;
					processAlarm();
				}
			} catch (DataAccessException ex) {
				throw new AppException(ex, ex.getMessage());
			}
		}
		return recordsInserted;
	}

	private void processAlarm() {
		List<UserContactRecords> contactsDM = getDMContactsfromDB();
		List<String> emailsDM = new ArrayList<String>();
		List<String> mobileDM = new ArrayList<String>();
		for(UserContactRecords user : contactsDM){
			emailsDM.add(user.getEmailId());
			mobileDM.add(user.getContactNo());
		}
		StringBuilder builder = new StringBuilder();
		if(null != infoList && !infoList.isEmpty()){
			for(String info : infoList){
				builder.append(info).append("\n");
			}
		}
		if(alarm > thresholdVulneabiltyVal){
			CommonUtils.initiateAlarmingEmail(builder.toString(), emailsDM);
			CommonUtils.initiateAlarmingCall(mobileDM);
		}
		
	}

	private List<UserContactRecords> getDMContactsfromDB() {
		List<UserContactRecords> contacts = new ArrayList<UserContactRecords>();
		try {
			contacts = getVulnerabilityDataDao().fetchDMContacts();
		} catch (DataAccessException ex) {
			throw new AppException(ex, ex.getMessage());
		}
		return contacts;
	}

	private List<AuditRecord> fetchVulnerableRecords(
			List<AuditRecord> rawAuditRecords) {
		List<AuditRecord> vulnerableRecords = new ArrayList<AuditRecord>();
		infoList = new ArrayList<String>();
		for(AuditRecord ar : rawAuditRecords){
			int seismicVal = ar.getSeismic();
			long auditDuration = CommonUtils.getDateDifference(ar.getAuditDate() , new Date());
			float evacTime = calculateEvacuationTime(ar.getEvacuationTimeinMin() , ar.getBuildingCitizenCount());
			if(auditDuration > 180  &&  auditDuration<= 360){
				ar.setVulnerabilityLevel(3);
				vulnerableRecords.add(ar);
			}else if(auditDuration > 360 ){
				alarm++;
				infoList.add("Very High Risk found for "+disasterTypeMap.get(ar.getDisasterTypeId())+" in area "
						+areaZipCode+" for Structure :"+ar.getBuildingName());
				ar.setVulnerabilityLevel(4);
				vulnerableRecords.add(ar);
			}
			else if(evacTime > 0.05 && evacTime < 0.10){
				ar.setVulnerabilityLevel(2);
				vulnerableRecords.add(ar);
			}else if(evacTime > 0.10 && evacTime < 0.20){
				ar.setVulnerabilityLevel(3);
				vulnerableRecords.add(ar);
			}else if(evacTime >= 0.20 ){
				alarm++;
				infoList.add("Very High Risk found for "+disasterTypeMap.get(ar.getDisasterTypeId())+" in area "
						+areaZipCode+" for Structure :"+ar.getBuildingName());
				ar.setVulnerabilityLevel(4);
				vulnerableRecords.add(ar);
			}
			else if(seismicVal != 0){
				alarm++;
				ar.setVulnerabilityLevel(4);
				ar.setDisasterTypeId(3);
				infoList.add("Very High Risk found for "+disasterTypeMap.get(ar.getDisasterTypeId())+" in area "
						+areaZipCode+" for Structure :"+ar.getBuildingName());
				vulnerableRecords.add(ar);
			}
		}
		return vulnerableRecords;
	}

	private float calculateEvacuationTime(int evacuationTimeinMin,
			int buildingCitizenCount) {
		float avgEscapeTime =((float)evacuationTimeinMin)/buildingCitizenCount;
		return avgEscapeTime;
	}



}
