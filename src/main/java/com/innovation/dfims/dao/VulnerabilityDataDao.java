package com.innovation.dfims.dao;

import java.sql.Date;
import java.util.ArrayList;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.support.JdbcDaoSupport;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import com.innovation.dfims.config.AppConstant;
import com.innovation.dfims.dao.mapper.AuditRecordMapper;
import com.innovation.dfims.dao.mapper.UserContactsRecordMapper;
import com.innovation.dfims.dto.AuditRecord;
import com.innovation.dfims.dto.UserContactRecords;


@Repository("vulnerabilityDataDao")
public class VulnerabilityDataDao extends JdbcDaoSupport implements IVulnerabilityDataDao{
	
	private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
	
	private static final String INSERT_VULNERABILITY_QRY = "insert into t_vulnerability (detection_date, disaster_type_id, area_id, vulenrability_status) "
			+ "values (:detectiondate,:disasterTypeId,:arearId,:status)";
	private static final String INSERT_VUL_BUILDING_QRY = "insert into t_vulnerability_building (vulnerability_id, building_id, vulnerability_level) "
			+ "values (:vulnerabilityId,:bulidingId,:level)";
	
	private static final String UPDATE_VUL_STATUS_QRY = "update t_vulnerability set vulenrability_status=:status,close_cmt=:comment,close_date=CURRENT_TIMESTAMP"
			+ " where vulnerability_id = :vulnerabilityId";
	
	@Autowired(required = true)
	public VulnerabilityDataDao(@Qualifier("dataSource") final DataSource dataSource)
	{
		super();
		System.out.println("dataSource::"+dataSource);
		setDataSource(dataSource);
		this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
	}

	@Override
	public List<AuditRecord> fetchAuditRecords() throws DataAccessException {
		List<AuditRecord> auditRecords = null;
		
		String sql = "select t_audits.audit_id , t_audits.audit_date, t_audits.building_id,"
				+ "t_audits.evac_time_min, t_audits.disaster_type_id, "
				+ "t_audits.seismic, t_buildings.area_id , t_buildings.building_citizen_count "
				+ ", t_buildings.building_name "
				+ "from  t_audits inner join t_buildings "
				+ "on t_audits.building_id=t_buildings.building_id";
				
		
		auditRecords = getJdbcTemplate().query(sql, new Object[] {},
				new AuditRecordMapper());
		return auditRecords;
	}

	@Override
	public String insertVulnerabiltyRecords(List<AuditRecord> vulnerableRecords)
			throws DataAccessException {
		MapSqlParameterSource parameters = null;
		KeyHolder holder = null;
		java.util.Date currentDate = new java.util.Date();
		Date detectiondate = new Date(currentDate.getTime());
		for(AuditRecord ar : vulnerableRecords){
			
			parameters = new MapSqlParameterSource();
			parameters.addValue("detectiondate", new java.sql.Date(detectiondate.getTime()));
			parameters.addValue("disasterTypeId",ar.getDisasterTypeId());
			parameters.addValue("arearId", ar.getAreaId());
			parameters.addValue("status", "O");
			holder = new GeneratedKeyHolder();
			namedParameterJdbcTemplate.update(INSERT_VULNERABILITY_QRY, parameters,holder, new String[] { "vulnerability_id" });
			
			int vulnerabilityId = holder.getKey().intValue();
			
			parameters = new MapSqlParameterSource();
			parameters.addValue("vulnerabilityId", vulnerabilityId);
			parameters.addValue("bulidingId", ar.getBuildingId());
			parameters.addValue("level", ar.getVulnerabilityLevel());
			namedParameterJdbcTemplate.update(INSERT_VUL_BUILDING_QRY, parameters);
			
		}
		return AppConstant.STATUS_SUCCESS;

	}
	
	@Override
	public List<UserContactRecords> fetchDMContacts()
			throws DataAccessException {
		List<UserContactRecords> contacts = new ArrayList<UserContactRecords>();

		String sql = "select t_users.user_email , t_users.user_mobile  "
				+ " from  t_users inner join t_roles "
				+ "on t_users.role_id=t_roles.role_id "
				+ " where t_roles.role_name='Disaster Management Team'";

		contacts = getJdbcTemplate().query(sql, new Object[] {},
				new UserContactsRecordMapper());

		return contacts;
	}
	
	
	@Override
	public String closeVulnerability(Integer vulnerabilityId, String comment) throws DataAccessException {
		String status = AppConstant.STATUS_SUCCESS;
		MapSqlParameterSource parameters = new MapSqlParameterSource();
		parameters.addValue("status", "C");
		parameters.addValue("vulnerabilityId", vulnerabilityId);
		parameters.addValue("comment", comment);
		namedParameterJdbcTemplate.update(UPDATE_VUL_STATUS_QRY, parameters);
		return status;
	}


}
